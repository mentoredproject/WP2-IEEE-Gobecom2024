<h2>Adaptive Packet Padding Approach for Smart Home Networks: A Tradeoff Between Privacy and Performance</h2>
Guide for conducting the experiments described in the paper "Adaptive Packet Padding Approach for Smart Home Networks: A Tradeoff Between Privacy and Performance":

- The experiment configuration is defined in the file "Data/Configuration/experiment_configuration.json". In this file, specify the padding type (Proposal or Existing) and the strategy (100, 500, 700, 900, mtu, random, random255, exponential, linear, and mouse_elephant);
- Produce the features for the original IoT traffic with the script "prepare_features.py". Please, in file "Data/Configuration/experiment_configuration.json", set 'None' for padding and paddingStrategy. Use these features to evaluate padding strategies;
- Update the configuration file with the padding type and strategy to be evaluated;
- The following instructions always assume you are in the project root folder;
- Run the script for padding with the desired strategy (scripts run_existing_padding.py and run_proposal_padding.py);
- The generated files are saved in the appropriate folder under Data/Processed/padding_data. The data generated by the strategies are separated into separate folders;
- Generate the packet length features with the script "prepare_features.py" for each of the strategies;
- Run the script "padding_strategies_evaluation.py" to evaluate padding strategies with the original and modified data;
- Analyze the results.

Note: we use multiple datasets, one per day, to analyze the results with statistical methods such as hypothesis testing. Files with IoT traffic are located in the "Data/Raw" folder. It is unnecessary to decompress the files before running the experiments.  

The files were converted from PCAP files made available by the authors of "A. Sivanathan et al., 'Classifying IoT Devices in Smart Environments Using Network Traffic Characteristics,' in IEEE Transactions on Mobile Computing, vol. 18, no. 8, pp. 1745-1759, 1 Aug. 2019, doi: 10.1109/TMC.2018.2866249." We use Wireshark software to perform this conversion. Configure Wireshark to display the time from the beginning of the capture in seconds.

If you use this code in a publication please cite the following paper:

A. J. Pinheiro, P. Freitas de Araujo-Filho, J. de M. Bezerra and D. R. Campelo, "Adaptive Packet Padding Approach for Smart Home Networks: A Tradeoff Between Privacy and Performance," in IEEE Internet of Things Journal, 2021.

@ARTICLE{9203848,  
author={Pinheiro, Ant√¥nio J. and Freitas de Araujo-Filho, Paulo and de M. Bezerra, Jeandro and Campelo, Divanilson R.},  journal={IEEE Internet of Things Journal},  title={Adaptive Packet Padding Approach for Smart Home Networks: A Tradeoff Between Privacy and Performance},  year={2021},  volume={8},  number={5},  pages={3930-3938},  doi={10.1109/JIOT.2020.3025988}}


## Configuring the environment for running Julia

### Install Julia
```sh
wget https://julialang-s3.julialang.org/bin/linux/x64/1.10/julia-1.10.2-linux-x86_64.tar.gz
```
```sh
tar zxvf julia-1.10.2-linux-x86_64.tar.gz -C /opt
```

```sh
export PATH="$PATH:/opt/julia-1.10.2/bin"
```

```sh
julia --version
```

### Install dependencies
```sh
julia adaptive_padding/padding/nearest/install_dependencies.jl 
```

## Run the experiment (using poetry)
Inside project root folder:

### On Windows:
```sh
set PYTHONPATH=%PYTHONPATH%;.
```

### On Linux:
```sh
export PYTHONPATH=$PYTHONPATH:.
```

### Install dependencies
```sh
poetry install
```

### Alternative environment (Docker)
Build a Docker image:
```sh
sudo docker build -t packet-padding -f Docker/Dockerfile .
```

Run the container (Linux):
```sh
docker run -v ./Data/:/app/Data --rm -it packet-padding
```

Run the container (Windows):
```sh
docker run -v .\Data\:/app/Data --rm -it packet-padding
```

<span style="color:red">Tip: copy the files generated with the results to the /app/Data/ folder</span>.

When using the Docker container, omit ```poetry run``` from the commands below.

### Apply padding strategies
```sh
poetry run python3 adaptive_padding/run_existing_padding.py
poetry run python3 adaptive_padding/run_proposal_padding.py
poetry run python3 adaptive_padding/run_nearest_padding.py
```

### Generate the features to evaluate privacy improvement
```sh
poetry run python3 adaptive_padding/prepare_features.py --filename experiment_configuration.json
poetry run python3 adaptive_padding/prepare_features.py --filename existing_experiment_configuration.json
poetry run python3 adaptive_padding/prepare_features.py --filename proposal_experiment_configuration.json
```

### Evaluate privacy improvement
This step can take a long time, depending on the computational power in which the experiment is carried out.
```sh
poetry run python3 adaptive_padding/padding_strategies_evaluation.py --filename existing_experiment_configuration.json
poetry run python3 adaptive_padding/padding_strategies_evaluation.py --filename proposal_experiment_configuration.json
```
At the end of executing this script, two files are created for each strategy evaluated. The ```.txt``` file contains the results for each CSV file, while the ```.json``` calculates average, minimum and maximum for each performance metric evaluated.

### Calculate the byte overhead generated by padding strategies
```sh
poetry run python3 adaptive_padding/compute_byte_overhead.py --filename existing_experiment_configuration.json
poetry run python3 adaptive_padding/compute_byte_overhead.py --filename proposal_experiment_configuration.json
```

### Produce graphs of results
```sh
poetry run python3 adaptive_padding/make_plots.py
```

## Adding new padding strategies.
The ```PaddingExperiment``` (```evaluation.py```) class can be used to apply the experiment to new padding strategies. The ```strategies_mapping``` parameter expects a dictionary with a ```string``` that identifies the strategy associated with the implementation of the ```PaddingStrategy```(```padding_strategy.py```) interface.

The ```pad``` method of the ```PaddingStrategy``` interface receives the original size and returns the new size of the packet.

If you want to use the code that runs this project's experiment with a new strategy, you can take the ```NearestPadding``` class as an example (```nearest_padding.py```). This class implements an example padding strategy in which the length is changed to the next closest value from a list of values. For example, 66 is changed to 100.

The ```run_nearest_padding.py``` script uses the ```NearestPadding``` strategy to change the size of packets contained in files in the Data/Raw folder.
